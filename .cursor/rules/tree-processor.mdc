---
name: tree-processor
description: Tree processor library development rules - comprehensive testing, multiple scenarios, no hardcoding
---

# Tree Processor 开发规则

## 核心原则

### 1. 完善的测试覆盖（Mandatory）

**所有新功能或修改必须包含完整的测试用例，测试覆盖率目标为 99%+。**

**注意：** 
- 当前源代码（src/index.ts）的测试覆盖率为 **99.67%**
- 函数覆盖率：**100%**
- 分支覆盖率：**99.32%**
- 语句覆盖率：**99.67%**
- 行覆盖率：**99.66%**

**关于不可达代码：**
- 某些代码行（如防御性编程的兜底返回语句）可能理论上不可达
- 这是正常的代码实践，不需要为了追求 100% 覆盖率而修改代码逻辑
- **99%+ 的覆盖率已经是非常高的水平，可以接受**

#### 测试要求：

- **基础功能测试**：测试正常使用场景，确保功能按预期工作
- **边界情况测试**：测试空数组、空树、单节点、深层嵌套等边界情况
- **异常处理测试**：测试无效输入、类型错误、null/undefined 等情况
- **自定义字段名测试**：测试使用自定义 children 和 id 字段名的场景
- **复杂场景测试**：测试多层嵌套、大量节点、特殊数据结构等复杂情况
- **副作用测试**：对于会修改原数据的方法（如 pushTree、removeTree），测试原数据是否被正确修改
- **返回值测试**：确保所有方法的返回值类型和内容正确

#### 测试结构规范：

```typescript
describe('方法名', () => {
  it('应该描述具体的测试场景', () => {
    // 测试代码
  });
  
  it('应该处理边界情况', () => {
    // 边界情况测试
  });
  
  it('应该支持自定义字段名', () => {
    // 自定义字段名测试
  });
  
  it('应该处理异常情况', () => {
    // 异常处理测试
  });
});
```

#### 测试数据要求：

- 使用 `beforeEach` 重置测试数据，确保测试之间互不干扰
- 创建多种不同结构的测试数据：
  - 简单树（1-2层）
  - 深层嵌套树（3+层）
  - 单节点树
  - 空树
  - 不平衡树（某些分支更深）
  - 包含特殊值的树（null、undefined、空字符串等）

### 2. 多种使用场景（No Hardcoding）

**代码必须支持多种使用场景，严禁硬编码。**

#### 禁止硬编码：

- ❌ **禁止硬编码字段名**：必须支持自定义 children 和 id 字段名
- ❌ **禁止硬编码数据结构**：代码必须能处理各种树结构数据
- ❌ **禁止硬编码值**：使用参数和配置，而非固定值
- ❌ **禁止假设数据格式**：必须处理各种可能的数据类型和结构

#### 必须支持：

- ✅ **自定义字段名**：所有方法必须支持 FieldNames 参数
- ✅ **灵活的数据结构**：支持各种节点数据结构（不假设特定字段）
- ✅ **类型安全**：使用 TypeScript 类型，但不限制数据结构
- ✅ **可配置性**：通过参数和配置对象控制行为

#### 示例：

```typescript
// ❌ 错误：硬编码字段名
function badExample(tree: any[]) {
  for (const node of tree) {
    if (node.children) { // 硬编码 'children'
      // ...
    }
  }
}

// ✅ 正确：支持自定义字段名
function goodExample(
  tree: TreeData,
  fieldNames: FieldNames = DEFAULT_FIELD_NAMES
) {
  for (const node of tree) {
    const children = node[fieldNames.children]; // 使用配置的字段名
    if (Array.isArray(children) && children.length > 0) {
      // ...
    }
  }
}
```

### 3. 测试场景覆盖清单

在编写测试时，必须覆盖以下场景：

#### 基础场景：
- [ ] 正常使用场景（标准树结构）
- [ ] 空数组/空树
- [ ] 单节点树
- [ ] 只有根节点的树（无子节点）

#### 结构场景：
- [ ] 浅层树（1-2层）
- [ ] 深层嵌套树（3+层）
- [ ] 不平衡树（不同分支深度不同）
- [ ] 单分支树（所有节点只有一个子节点）
- [ ] 多分支树（节点有多个子节点）

#### 数据场景：
- [ ] 节点包含各种数据类型（string, number, boolean, object, array）
- [ ] 节点包含 null/undefined 值
- [ ] 节点包含空字符串
- [ ] 节点包含特殊字符
- [ ] 节点 ID 为各种类型（number, string）

#### 自定义字段名场景：
- [ ] 使用默认字段名（children, id）
- [ ] 使用自定义字段名（如 subNodes, nodeId）
- [ ] 使用中文字段名
- [ ] 使用特殊字符字段名

#### 边界和异常场景：
- [ ] 传入 null/undefined
- [ ] 传入非数组类型
- [ ] 节点缺少 children 字段
- [ ] 节点 children 不是数组
- [ ] 节点缺少 id 字段
- [ ] 重复的 id 值
- [ ] 非常大的树结构（性能测试）

#### 副作用场景（对于修改原数据的方法）：
- [ ] 原数据是否被正确修改
- [ ] 修改后树结构是否保持完整
- [ ] 引用关系是否正确

### 4. 代码质量要求

#### 类型安全：
- 使用 TypeScript 严格模式
- 为所有函数参数和返回值提供类型定义
- 使用泛型提高代码复用性
- 避免使用 `any`，必要时使用 `unknown`

#### 错误处理：
- 对无效输入进行验证和错误处理
- 提供清晰的错误信息
- 对于可能失败的操作，返回明确的成功/失败状态

#### 性能考虑：
- 避免不必要的递归
- 使用迭代而非递归（如果可能）
- 考虑大树的性能表现
- 避免创建不必要的中间数组

#### 代码风格：
- 使用清晰的变量和函数命名
- 添加必要的注释（特别是复杂逻辑）
- 保持函数单一职责
- 遵循项目的代码风格

### 5. 开发流程

#### 标准开发流程

1. **需求分析**：理解功能需求，考虑各种使用场景
2. **设计实现**：编写代码，确保支持多种场景，避免硬编码
3. **编写测试**：在实现代码的同时或之后立即编写测试
4. **测试覆盖**：确保所有场景都有测试覆盖
5. **运行测试**：运行 `npm test` 确保所有测试通过
6. **检查覆盖率**：运行 `npm run test:coverage` 检查覆盖率，目标 100%
7. **代码审查**：检查代码质量和是否遵循规则
8. **更新文档**：如有必要，更新 README.md

#### 新增功能开发流程

```powershell
# 1. 创建功能分支
git checkout -b feature/new-function-name

# 2. 编写代码和测试
# 编辑 src/index.ts 和 src/index.test.ts

# 3. 运行测试确保通过
npm test -- --run

# 4. 检查覆盖率
npm run test:coverage

# 5. 构建项目
npm run build

# 6. 检查打包体积
npm run size:dist

# 7. 提交代码
git add .
git commit -m "feat: add new function"

# 8. 推送到远程
git push origin feature/new-function-name
```

#### 修复 Bug 流程

```powershell
# 1. 创建修复分支
git checkout -b fix/bug-description

# 2. 编写测试重现问题
# 在测试文件中添加失败的测试用例

# 3. 修复代码使测试通过
# 编辑 src/index.ts

# 4. 运行测试确保修复
npm test -- --run

# 5. 检查是否引入新问题
npm run test:coverage

# 6. 提交修复
git add .
git commit -m "fix: description of the bug fix"
```

#### 发布新版本流程

```powershell
# 1. 确保所有测试通过
npm test -- --run

# 2. 检查覆盖率
npm run test:coverage

# 3. 构建项目
npm run build

# 4. 更新版本号（遵循语义化版本）
# 编辑 package.json 中的 version 字段

# 5. 更新 CHANGELOG.md（如果存在）

# 6. 提交版本更新
git add .
git commit -m "chore: bump version to x.x.x"

# 7. 创建标签
git tag vx.x.x

# 8. 推送到远程
git push origin main --tags

# 9. 发布到 npm
npm publish
```

### 6. 开发命令（PowerShell）

#### 项目初始化
```powershell
# 安装依赖
npm install

# 或使用 yarn
yarn install
```

#### 开发与测试
```powershell
# 运行所有测试（监听模式）
npm test

# 运行测试（单次，不监听文件变化）
npm test -- --run

# 运行测试并生成覆盖率报告
npm run test:coverage

# 查看覆盖率报告（HTML）
Start-Process coverage/index.html
```

#### 构建与打包
```powershell
# 构建项目
npm run build

# 检查打包体积
npm run size:dist

# 检查源代码体积
npm run size:src

# 检查所有体积
npm run size:all

# 查看打包分析报告
Start-Process dist/stats.html
```

#### 代码质量检查
```powershell
# 运行 TypeScript 类型检查
npx tsc --noEmit

# 运行 ESLint（如果配置了）
npx eslint src/

# 运行 Prettier（如果配置了）
npx prettier --check src/
```

#### 发布流程
```powershell
# 发布前会自动运行 build（prepublishOnly hook）
npm publish

# 发布测试版本
npm publish --tag beta

# 查看将要发布的文件
npm pack --dry-run
```

#### 常用 PowerShell 命令
```powershell
# 清理构建文件
Remove-Item -Recurse -Force dist, coverage -ErrorAction SilentlyContinue

# 清理 node_modules（重新安装）
Remove-Item -Recurse -Force node_modules; npm install

# 查看文件大小
Get-ChildItem dist/*.js | Select-Object Name, @{Name="Size(KB)";Expression={[math]::Round($_.Length/1KB,2)}}

# 查看测试文件
Get-ChildItem src/*.test.ts | Select-Object Name, Length
```

### 7. 示例：完整的测试用例模板

```typescript
describe('新方法名', () => {
  let treeData: TreeData;
  let customTreeData: TreeData; // 使用自定义字段名的测试数据

  beforeEach(() => {
    // 标准测试数据
    treeData = [
      {
        id: 1,
        name: 'node1',
        children: [
          { id: 2, name: 'node2' },
          { id: 3, name: 'node3' },
        ],
      },
    ];

    // 自定义字段名测试数据
    customTreeData = [
      {
        nodeId: 1,
        name: 'node1',
        subNodes: [
          { nodeId: 2, name: 'node2' },
          { nodeId: 3, name: 'node3' },
        ],
      },
    ];
  });

  describe('基础功能', () => {
    it('应该处理正常使用场景', () => {
      // 测试代码
    });

    it('应该处理空数组', () => {
      const result = newMethod([], /* ... */);
      expect(result).toEqual(/* 期望值 */);
    });

    it('应该处理单节点树', () => {
      const singleNode = [{ id: 1, name: 'node1' }];
      const result = newMethod(singleNode, /* ... */);
      expect(result).toEqual(/* 期望值 */);
    });
  });

  describe('自定义字段名', () => {
    it('应该支持自定义 children 和 id 字段名', () => {
      const fieldNames = { children: 'subNodes', id: 'nodeId' };
      const result = newMethod(customTreeData, /* ... */, fieldNames);
      expect(result).toEqual(/* 期望值 */);
    });
  });

  describe('边界情况', () => {
    it('应该处理深层嵌套树', () => {
      // 创建深层嵌套树
      // 测试代码
    });

    it('应该处理不平衡树', () => {
      // 创建不平衡树
      // 测试代码
    });
  });

  describe('异常处理', () => {
    it('应该处理 null/undefined 输入', () => {
      // 测试代码
    });

    it('应该处理无效的树结构', () => {
      // 测试代码
    });
  });
});
```

### 8. 项目结构

```
tree-processor/
├── src/                    # 源代码目录
│   ├── index.ts           # 主入口文件，包含所有函数
│   ├── index.test.ts      # 主测试文件
│   ├── import.test.ts     # 导入测试
│   └── npm-import.test.ts # npm 包导入测试
├── dist/                   # 构建输出目录
│   ├── tree-processor.esm.js  # ESM 格式
│   ├── tree-processor.cjs.js  # CommonJS 格式
│   ├── tree-processor.umd.js  # UMD 格式
│   ├── index.d.ts         # TypeScript 类型定义
│   └── stats.html         # 打包分析报告
├── coverage/               # 测试覆盖率报告
├── scripts/               # 构建脚本
│   ├── check-size.js      # 检查打包体积
│   └── check-src-size.js  # 检查源代码体积
├── .cursor/               # Cursor IDE 配置
│   └── rules/             # 开发规则
├── package.json           # 项目配置
├── tsconfig.json          # TypeScript 配置
├── vitest.config.ts       # Vitest 测试配置
├── rollup.config.js       # Rollup 打包配置
└── README.md              # 项目文档
```

### 9. 技术栈

- **TypeScript** 5.7+ - 类型系统
- **Vitest** 4.0+ - 测试框架
- **Rollup** 4.0+ - 模块打包工具
- **Terser** - JavaScript 压缩工具
- **tslib** - TypeScript 运行时库

### 10. 代码规范

#### TypeScript 配置要求

- 使用严格模式（`strict: true`）
- 目标 ES2020
- 模块系统：ESNext
- 启用声明文件生成

#### 命名规范

- **函数名**：使用驼峰命名，动词开头（如 `mapTree`, `findTree`）
- **类型名**：使用帕斯卡命名（如 `TreeNode`, `TreeData`, `FieldNames`）
- **变量名**：使用驼峰命名（如 `treeData`, `fieldNames`）
- **常量名**：使用大写下划线（如 `DEFAULT_FIELD_NAMES`）

#### 导出规范

- 所有函数使用命名导出（`export function`）
- 提供默认导出对象，包含所有方法
- 类型定义单独导出（`export type`, `export interface`）

#### 注释规范

- 所有公共函数必须有 JSDoc 注释
- 复杂逻辑需要行内注释
- 使用中文注释（与项目文档保持一致）

### 11. 性能要求

- 所有函数应该能够处理大型树结构（1000+ 节点）
- 避免深度递归导致的栈溢出
- 考虑使用迭代替代递归（如果可能）
- 避免创建不必要的中间数组

### 12. 兼容性要求

- 支持 Node.js 14+
- 支持现代浏览器（ES2020+）
- 提供 ESM、CJS、UMD 三种格式
- 支持 TypeScript 和 JavaScript 项目

## 总结

### ✅ 必须遵守

- ✅ 编写完善的测试，覆盖所有场景
- ✅ 支持多种使用场景，避免硬编码
- ✅ 支持自定义字段名
- ✅ 处理边界情况和异常情况
- ✅ 测试覆盖率目标 100%（当前 94%）
- ✅ 使用 PowerShell 语法执行命令
- ✅ 遵循代码规范和命名规范
- ✅ 所有公共函数必须有 JSDoc 注释

### ❌ 严格禁止

- ❌ 硬编码字段名、数据结构或值
- ❌ 假设特定的数据结构或格式
- ❌ 在测试通过前提交代码
- ❌ 提交未构建的代码
- ❌ 忽略 TypeScript 类型错误
- ❌ 使用 `any` 类型（除非必要）
