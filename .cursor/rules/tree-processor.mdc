---
name: tree-processor
description: Tree processor library development rules - comprehensive testing, multiple scenarios, no hardcoding
---

# Tree Processor 开发规则

## 核心原则

### 1. 完善的测试覆盖（Mandatory）

**所有新功能或修改必须包含完整的测试用例，测试覆盖率必须达到 100%。**

#### 测试要求：

- **基础功能测试**：测试正常使用场景，确保功能按预期工作
- **边界情况测试**：测试空数组、空树、单节点、深层嵌套等边界情况
- **异常处理测试**：测试无效输入、类型错误、null/undefined 等情况
- **自定义字段名测试**：测试使用自定义 children 和 id 字段名的场景
- **复杂场景测试**：测试多层嵌套、大量节点、特殊数据结构等复杂情况
- **副作用测试**：对于会修改原数据的方法（如 pushTree、removeTree），测试原数据是否被正确修改
- **返回值测试**：确保所有方法的返回值类型和内容正确

#### 测试结构规范：

```typescript
describe('方法名', () => {
  it('应该描述具体的测试场景', () => {
    // 测试代码
  });
  
  it('应该处理边界情况', () => {
    // 边界情况测试
  });
  
  it('应该支持自定义字段名', () => {
    // 自定义字段名测试
  });
  
  it('应该处理异常情况', () => {
    // 异常处理测试
  });
});
```

#### 测试数据要求：

- 使用 `beforeEach` 重置测试数据，确保测试之间互不干扰
- 创建多种不同结构的测试数据：
  - 简单树（1-2层）
  - 深层嵌套树（3+层）
  - 单节点树
  - 空树
  - 不平衡树（某些分支更深）
  - 包含特殊值的树（null、undefined、空字符串等）

### 2. 多种使用场景（No Hardcoding）

**代码必须支持多种使用场景，严禁硬编码。**

#### 禁止硬编码：

- ❌ **禁止硬编码字段名**：必须支持自定义 children 和 id 字段名
- ❌ **禁止硬编码数据结构**：代码必须能处理各种树结构数据
- ❌ **禁止硬编码值**：使用参数和配置，而非固定值
- ❌ **禁止假设数据格式**：必须处理各种可能的数据类型和结构

#### 必须支持：

- ✅ **自定义字段名**：所有方法必须支持 FieldNames 参数
- ✅ **灵活的数据结构**：支持各种节点数据结构（不假设特定字段）
- ✅ **类型安全**：使用 TypeScript 类型，但不限制数据结构
- ✅ **可配置性**：通过参数和配置对象控制行为

#### 示例：

```typescript
// ❌ 错误：硬编码字段名
function badExample(tree: any[]) {
  for (const node of tree) {
    if (node.children) { // 硬编码 'children'
      // ...
    }
  }
}

// ✅ 正确：支持自定义字段名
function goodExample(
  tree: TreeData,
  fieldNames: FieldNames = DEFAULT_FIELD_NAMES
) {
  for (const node of tree) {
    const children = node[fieldNames.children]; // 使用配置的字段名
    if (Array.isArray(children) && children.length > 0) {
      // ...
    }
  }
}
```

### 3. 测试场景覆盖清单

在编写测试时，必须覆盖以下场景：

#### 基础场景：
- [ ] 正常使用场景（标准树结构）
- [ ] 空数组/空树
- [ ] 单节点树
- [ ] 只有根节点的树（无子节点）

#### 结构场景：
- [ ] 浅层树（1-2层）
- [ ] 深层嵌套树（3+层）
- [ ] 不平衡树（不同分支深度不同）
- [ ] 单分支树（所有节点只有一个子节点）
- [ ] 多分支树（节点有多个子节点）

#### 数据场景：
- [ ] 节点包含各种数据类型（string, number, boolean, object, array）
- [ ] 节点包含 null/undefined 值
- [ ] 节点包含空字符串
- [ ] 节点包含特殊字符
- [ ] 节点 ID 为各种类型（number, string）

#### 自定义字段名场景：
- [ ] 使用默认字段名（children, id）
- [ ] 使用自定义字段名（如 subNodes, nodeId）
- [ ] 使用中文字段名
- [ ] 使用特殊字符字段名

#### 边界和异常场景：
- [ ] 传入 null/undefined
- [ ] 传入非数组类型
- [ ] 节点缺少 children 字段
- [ ] 节点 children 不是数组
- [ ] 节点缺少 id 字段
- [ ] 重复的 id 值
- [ ] 非常大的树结构（性能测试）

#### 副作用场景（对于修改原数据的方法）：
- [ ] 原数据是否被正确修改
- [ ] 修改后树结构是否保持完整
- [ ] 引用关系是否正确

### 4. 代码质量要求

#### 类型安全：
- 使用 TypeScript 严格模式
- 为所有函数参数和返回值提供类型定义
- 使用泛型提高代码复用性
- 避免使用 `any`，必要时使用 `unknown`

#### 错误处理：
- 对无效输入进行验证和错误处理
- 提供清晰的错误信息
- 对于可能失败的操作，返回明确的成功/失败状态

#### 性能考虑：
- 避免不必要的递归
- 使用迭代而非递归（如果可能）
- 考虑大树的性能表现
- 避免创建不必要的中间数组

#### 代码风格：
- 使用清晰的变量和函数命名
- 添加必要的注释（特别是复杂逻辑）
- 保持函数单一职责
- 遵循项目的代码风格

### 5. 开发流程

1. **需求分析**：理解功能需求，考虑各种使用场景
2. **设计实现**：编写代码，确保支持多种场景，避免硬编码
3. **编写测试**：在实现代码的同时或之后立即编写测试
4. **测试覆盖**：确保所有场景都有测试覆盖
5. **运行测试**：运行 `npm test` 确保所有测试通过
6. **检查覆盖率**：运行 `npm run test:coverage` 确保覆盖率 100%
7. **代码审查**：检查代码质量和是否遵循规则
8. **更新文档**：如有必要，更新 README.md

### 6. 测试命令

```bash
# 运行所有测试
npm test

# 运行测试并生成覆盖率报告
npm run test:coverage

# 运行测试（单次，不监听文件变化）
npm test -- --run
```

### 7. 示例：完整的测试用例模板

```typescript
describe('新方法名', () => {
  let treeData: TreeData;
  let customTreeData: TreeData; // 使用自定义字段名的测试数据

  beforeEach(() => {
    // 标准测试数据
    treeData = [
      {
        id: 1,
        name: 'node1',
        children: [
          { id: 2, name: 'node2' },
          { id: 3, name: 'node3' },
        ],
      },
    ];

    // 自定义字段名测试数据
    customTreeData = [
      {
        nodeId: 1,
        name: 'node1',
        subNodes: [
          { nodeId: 2, name: 'node2' },
          { nodeId: 3, name: 'node3' },
        ],
      },
    ];
  });

  describe('基础功能', () => {
    it('应该处理正常使用场景', () => {
      // 测试代码
    });

    it('应该处理空数组', () => {
      const result = newMethod([], /* ... */);
      expect(result).toEqual(/* 期望值 */);
    });

    it('应该处理单节点树', () => {
      const singleNode = [{ id: 1, name: 'node1' }];
      const result = newMethod(singleNode, /* ... */);
      expect(result).toEqual(/* 期望值 */);
    });
  });

  describe('自定义字段名', () => {
    it('应该支持自定义 children 和 id 字段名', () => {
      const fieldNames = { children: 'subNodes', id: 'nodeId' };
      const result = newMethod(customTreeData, /* ... */, fieldNames);
      expect(result).toEqual(/* 期望值 */);
    });
  });

  describe('边界情况', () => {
    it('应该处理深层嵌套树', () => {
      // 创建深层嵌套树
      // 测试代码
    });

    it('应该处理不平衡树', () => {
      // 创建不平衡树
      // 测试代码
    });
  });

  describe('异常处理', () => {
    it('应该处理 null/undefined 输入', () => {
      // 测试代码
    });

    it('应该处理无效的树结构', () => {
      // 测试代码
    });
  });
});
```

## 总结

- ✅ **必须**：编写完善的测试，覆盖所有场景
- ✅ **必须**：支持多种使用场景，避免硬编码
- ✅ **必须**：支持自定义字段名
- ✅ **必须**：处理边界情况和异常情况
- ✅ **必须**：确保测试覆盖率 100%
- ❌ **禁止**：硬编码字段名、数据结构或值
- ❌ **禁止**：假设特定的数据结构或格式
- ❌ **禁止**：在测试通过前提交代码
